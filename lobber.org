# lobber.org (in Emacs -*- org -*- mode)

* What
Project notes about 'lobber', a closed BitTorrent tracker and
torrent index for the Nordic NREN's, operated by NORDUnet.
* Terms used in this document
- Shared file -- one or more files a user wants to share with other people
- Torrent -- a file with information about i) the file that is shared
  and ii) the URL of the tracker.
* Requirements
** Functional
- A web page for uploading torrents (HTTP PUT/POST client->server)
  - Uploading a torrent requires WebSSO (+oauth?) authentication
    - Do we need authorization or can all authenticated users upload?
- A web page listing and serving torrents (HTTP GET server->client)
  - Access to the list of torrents requires WebSSO (+oauth?)
    authentication
  - There shall be an RSS/Atom feed with available torrents
- A running BiTorrent tracker ([[http://erdgeist.org/arts/software/opentracker/][opentracker]] has been suggested)
- Anybody that has the torrent file may download the shared file
** Performance
- At least [x] torrent uploads per [time unit]
- At least [x] torrents served per [time unit]
- At least [x] torrents hosted on the server
- At least 100k simultaneous bittorrent _users_, whatever that means
  for the tracker (FIXME: find some numbers)
* Design
** Closing down opentracker
Do we need to close down the tracker to avoid people using it?  I
think so.  The way of doing this is to compile with
WANT_ACCESSLIST_WHITE and then update a whitelist file on the tracker
server (20 bytes) for each new torrent and SIGHUP the tracker.

- How many times per second can we do that and with how big a file
  before it becomes unfeasable?

- How do we remove entries from the whitelist file?

- How would this work with clusters of trackers?
** Alternative whitelist implementation
*** Requirements
- few readers
- few writers
- all on separate hosts
- search speed is paramount
- write speed is [subordinate]
*** Contenders
- DYI hash table (-networking, +simple)
- DYI b-tree
- BerkleyDB + some DYI networking
- filesystem, webdav, httpd caching (much like hash table)
- [[http://1978th.net/tokyocabinet/][TokioCabinet]] (-networking, +simple) pretty much the same as the DIY
  alternatives w/o writing the low level stuff, good
- [[http://couchdb.apache.org/][CouchDB]] -- HTTP, JSON
- [[http://incubator.apache.org/cassandra/][Cassandra]] ([[http://en.wikipedia.org/wiki/Cassandra_%28database%29][@wikipedia]]) -- might be too heavy ("ColumnFamily-based
  data model richer than typical key/value systems")
- Redis
- MongoDB
- Hypertable
*** Take two
- Let's use http.  It's slow, yes, but it can be made ok.
- Cache responses in (each) tracker, positive and negative.
- 
** Data model
*** Take 1
- The central object is an upload object (Upload) which has data and
  may have meta data (Metadata).
  - An Upload is created from data (the shared file(s)), a torrent
    file or perhaps something else.
  - An Upload has a TTL.
- An upload object can have zero or more upload access objects
  (Access) associated to it.
*** Take 2 <2009-12-02 Wed>
#+BEGIN_EXAMPLE
(type 'resource
  (name :text)     
  (description :text :optional)
  (owner :user)
  (acl :acl :optional)  ; default: no access
  (file :file :optional)  ; present => resource represents a torrent file
  (next :resource :optional)) ; present => res. repr. a tag

(type 'handle
  (secret :text)
  (expiration :date)
  (resource :resource))

(type 'user)
  (name :text :unique))

(type 'acl       ; first match
  (id :user)
  (permisssions :int))  ; two bits -- read and write
#+END_EXAMPLE
*** Take 3 <2009-12-11 Fri>
See [[file:src/lobber/share/models.py][file:~/p/lobber/src/lobber/share/models.py]] for data model.

- There are four object types: torrrent, tag, user and key.

- There are five object operations: get, list, create, update and
  delete.

  Except for the user object type, all operations are valid on all
  object types.  For user objects, only get is valid (i.e. we don't
  expose user management in the API).

- The canonical form of a URL is

  https://HOST.DOMAIN.TLD/APPLICATION/OBJECT-TYPE/[INSTANCE][.REPRESENTATION]][?lkey=SECRET]

  | instance / request method | GET  | POST/PUT | HEAD   | DELETE |
  |---------------------------+------+----------+--------+--------|
  | no instance given         | list | create   | -      | -      |
  | instance given            | get  | update   | existp | delete |
  |---------------------------+------+----------+--------+--------|

- There are four representations: raw, json, html and rss.

  Suffixing an object name (i.e. an instance or operation) in a URL
  with a dot and one of the representations will result in the
  object(s) being returned in this specific form.

  Another way for a client to specify representation is to use the
  HTTP Accept request-header [RFC2616 section 14.1].

  URL suffixes take precedence over Accept headers so that the user
  might be able to override the behaviour of an application.

  If the representation is missing, it's up to the object
  implementation to pick a suitable representation.

- The text representation of a key (the URL secret) is the sha256 sum
  of some decently random value.

  (We might want to use sha1 instead to get the length of the secret
  down from 64 to 40 characters but I don't know really.)

- Examples of how URL's map to database queries.
  - wget https://.../torrent/foo.torrent?lobberkey=secret0 ==>
    - select from torrent where owner=<secret0->owner> and name="foo"

- An access control list (ACL) is associated with a user via a key.

  Anyone who knows the secret in the key will be able to act on behalf
  of that user.  The ACL consists of regular expressions denoting if
  an action is allowed by matching it against the URL.  First match
  wins.

#+BEGIN_EXAMPLE
  ACL -- key -- user
                 /\
                /  \
              tag  torrent
#+END_EXAMPLE	      

  - A key has zero or one ACL.
  - An ACL has one or more keys.
  - A key has one owner (user).
  - A user has zero or more keys.
  - A user has zero or more torrents and tags.
  - A torrent has one owner (user).
  - A torrent has zero or more tags.
  - A tag has one owner (user).
  - A tag has zero or more torrents.

- Requests from a user with an HTTP session (cookie) is treated as if
  the request had contained a secret for a key tied to the logged in
  user with an ACL containing an entry with the value of ".*".
*** Take 4 <2010-02-27 Sat>
#+BEGIN_EXAMPLE
+------+       1 +---------+       1 +-----+
| tag  | ------- | torrent | ------- | acl |
+------+ 0..*    +---------+ 1       +-----+

+--------+       1 +-----+       1 +--------------+
| url-   | ------- | key | ------- | entitlements |
| filter | 1       +-----+ 1       +--------------+
+--------+     

entitlement := [a-z0-9_-]+   # note: not '$'
permission := 'r' | 'w'
ace := <entitlement> '#' <permission>
acl := <ace>+

entitlements := <entitlement>+

filter-re := [a-z0-9.*]+   # simplified regular expression
url-filter := <filter-re>+

key := sha256(random value)

**** Default ACL's and default entitlements
- When creating a torrent, its ACL is set to 'user:<login>#w'.

The question is: What's the 'login' when not logged in but coming in
via a key?  And the answer to that is that the user name is
'key:<secret>'.  So when creating a torrent using a key, it's
important that the ACL is extended with
f.ex. 'user:<user.creator.username>#w', if the creator of the key
should own the torrent created using the key.

- When creating a key, the entitlement is set and never changed after
  that.  This is important for tracking ownership of torrents, audit
  aside.
**** Permissions
Permission #r:
  - list torrent
  - read torrent
  - read acl on torrent
Permission #w:
  - delete torrent
  - write acl on torrent (ace := entitlement carried (or "below"?))
  - tag torrent (tag := entitlement carried or below)

**** Use cases
Use case #1: User U sharing torrent T with non-authenticated user
             (prereq: T has an ace 'user:<U>#w')
1. POST https://.../key   # key with 'key/' and 'user:<U>' required
        filter = 'torrent/<T>'
        entls = 'user:<U>:$self'   # note: '$self' is magic and expands to
                                   # the newly created key
   ==> K   # new key
2. POST https:/.../acl/T   # key with 'acl/T' and 'user:<U>:<K>' required
        ace = 'user:<U>:<K>#r'
   
#+END_EXAMPLE

** Web
*** Upload torrent
#+BEGIN_EXAMPLE
File: [input, path to file]
Share: [check box, default true]
Name: [input, text, optional]
Upload: [button] ==> Torrent uploaded
GET upload ==> "What's your preferred..." (upload.html)
           button: torrent_ul javaws_ul
                        \       /
			 \     / 
			  \   / (POST)
			   \ /
			 upload() [view.py]
			   /\
			  /  \
                  torrent_ul javaws_ul
			/      \
		       /        \
		      /    render launch.jnpl w/ "sessionid", "announce_url" and "apiurl"
		     /                                             |
	   render upload-torrent.html + UploadTorrent()      <share pressed>
	            |                                           /
   	      <share pressed> 				       /
	            \					      /
		     \					     /
		      ------ POST torrent/create ------------
		                       |
 			        torrent_create()
				       FIXME
		      
#+END_EXAMPLE
*** Torrent uploaded
#+BEGIN_EXAMPLE
Your torrent has been uploaded [and shared].
Your torrent: [URL] ==> Admin torrent
#+END_EXAMPLE
*** Admin torrent
TODO
*** List published torrents
TODO
* Notes
** NRKbeta and opentracker
http://search.cpan.org/dist/WWW-Opentracker-Stats/
** Playing with torrent files
On nordushare-dev, the 'bittorrent' package was installed.
*** make a torrent file
  btmakemetafile FILE http://nordushare-dev.nordu.net:4711/announce
*** view a torrent file
#+BEGIN_EXAMPLE
linus@nordushare-dev:~/tmp$ btshowmetainfo FILE.torrent
btshowmetainfo 20021207 - decode BitTorrent metainfo files

metainfo file.: vmlinuz.torrent
info hash.....: fd5c5211671b261b289dfe12a1d657b898b75902
file name.....: vmlinuz
file size.....: 3907424 (14 * 262144 + 237408)
announce url..: http://nordushare-dev.nordu.net:4711/announce
#+END_EXAMPLE
** Check out
- that bit in torrents the DHT article was talking about
** URL for torrent access control
/torrent/exists/<hashval>
* Progress [4/8]
** For Uutrecht
- [ ] web api
      - GET torrent/<inst>
- [X] more web: create keys
** General (also listed in Jira)
- [X] [[https://project.nordu.net/browse/LOBBERDEV-1][Federated login]]
- [ ] Send email to selected users with link to torrent file (after upload)
- [ ] http API (with ACL:s)
- [ ] remove 'nordushare' from url
- [ ] dig around in torrent file for description ("name") and more
      - s/name/notes/1 in class Torrent and store "name" from torrent
        file here.  The user can edit this field later.  The torrent
        file is stored as <hash>.torrent.
      Torrent spec: http://www.bittorrent.org/beps/bep_0003.html
** Needed for demo 2009-12-18 [6/8]
- [X] Working tracker running
- [X] Dummy page in Django
- [X] List of public, non expired torrents on start page
- Uploading torrent file
  - [X] Torrent and one Handle object is created in database
  - [X] File lands on disk
  - [X] Whitelist is updated and HUP is sent to tracker
- [X] Client is running, seeding everything in database (that hasn't expired)
- [X] _Some_ authentication
- [ ] Tracker sends 4xx rather than 5xx on "not allowed"
- [X] Save torrent files named as the hash of the torrent, present them in
      web as what was typed in as "name" (content-disposition?)
- [ ] Send mail with links on torrent creation
*** Use cases
** For 0.1, after 2009-12-16
- [ ] Proper DNS names
- [ ] Old torrent files are removed, from index (i.e. web page) and from whitelist
- [X] Proper Apache in front of Django
* Questions
- Should we flag the torrents as private?
* Flow
** User fills in a web form
#+BEGIN_EXAMPLE
- lobber/share/urls.py
- lobber/share/views.py (req.method != 'POST')
  render_to_response(SOME-FILE.html, lobber.share.forms.SOME-FORM)
- templ/share/SOME-FILE.html
  action=SOME-ACTION
- lobber/share/urls.py
- lobber/share/views.py (req.method == 'POST')
  if lobber.share.forms.SOME-FORM().is_valid():
#+END_EXAMPLE
     
* Operations
** Installing opentracker
cd /u/src
cvs -d :pserver:cvs@cvs.fefe.de:/cvs -z9 co libowfat
cd libowfat && make
cd /u/src
cvs -d :pserver:anoncvs@cvs.erdgeist.org:/home/cvsroot co opentracker
cd opentracker && patch << EOF
Index: Makefile
===================================================================
RCS file: /home/cvsroot/opentracker/Makefile,v
retrieving revision 1.66
diff -u -r1.66 Makefile
--- Makefile    12 Nov 2009 10:18:27 -0000      1.66
+++ Makefile    9 Mar 2010 13:44:10 -0000
@@ -22,7 +22,7 @@
 #FEATURES+=-DWANT_V6
 
 #FEATURES+=-DWANT_ACCESSLIST_BLACK
-#FEATURES+=-DWANT_ACCESSLIST_WHITE
+FEATURES+=-DWANT_ACCESSLIST_WHITE
 
 #FEATURES+=-DWANT_SYNC_LIVE
 #FEATURES+=-DWANT_SYNC_SCRAPE
@@ -41,7 +41,7 @@
 #FEATURES+=-D_DEBUG_HTTPERROR
 
 OPTS_debug=-D_DEBUG -g -ggdb # -pg -fprofile-arcs -ftest-coverage
-OPTS_production=-Os
+#OPTS_production=-Os
 
 CFLAGS+=-I$(LIBOWFAT_HEADERS) -Wall -pipe -Wextra #-ansi -pedantic
 LDFLAGS+=-L$(LIBOWFAT_LIBRARY) -lowfat -pthread -lpthread -lz
EOF
make
** Apache configuration
        <Location "/">
           SetHandler python-program
           PythonHandler django.core.handlers.modpython
           SetEnv DJANGO_SETTINGS_MODULE lobber.settings
           PythonDebug On
           PythonPath "['/home/nordushare/lobber/src'] + sys.path"

           AuthType shibboleth
           ShibRequireSession Off
           require shibboleth
           RequestHeader set X_REMOTE_USER %{eppn}e
           RequestHeader set EPPN %{eppn}e
           RequestHeader set GIVENNAME %{givenName}e
           RequestHeader set SN %{sn}e
           RequestHeader set MAIL %{mail}e
           RequestHeader set AFFILIATION %{affiliation}e
        </Location>

        <LocationMatch "Shibboleth.sso">
           SetHandler None
        </LocationMatch>

        <Location "/nordushare/login-federated/">
           AuthType shibboleth
           ShibRequireSession On
           require valid-user
        </Location>

        Alias /media /usr/share/pyshared/django/contrib/admin/media/
        Alias /jars /var/www/jars/
        Alias /css /var/www/css/
        Alias /js /var/www/js/
        # Allow indexing during development.  TODO: Remove.
        <LocationMatch "^/(jars|css|js|media)">
           Options Indexes FollowSymLinks
           Order allow,deny
           allow from all
           SetHandler None
        </LocationMatch>
